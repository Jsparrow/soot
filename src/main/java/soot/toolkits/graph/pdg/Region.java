package soot.toolkits.graph.pdg;

/*-
 * #%L
 * Soot - a J*va Optimization Framework
 * %%
 * Copyright (C) 1999 - 2010 Hossein Sadat-Mohtasham
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 2.1 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 * 
 * You should have received a copy of the GNU General Lesser Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-2.1.html>.
 * #L%
 */

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.toolkits.graph.Block;
import soot.toolkits.graph.UnitGraph;

/**
 * This class was originally designed to represent a weak region. Later, PDGRegion was designed to represent a richer region
 * representation but since there were cases that we wanted to enforce the use of Region instead of PDGRegion, and for some
 * other compatibility issues, we chose not to eliminate this class and even not to factor it into a common abstract class.
 *
 * One major contributing factor to the above is that, a Region can exist independent from a PDG since they are generated by
 * RegionAnalysis, whereas a PDGRegion is generated by a PDG.
 *
 * @author Hossein Sadat-Mohtasham Jan 2009
 */

public class Region implements IRegion {

  private SootClass mClass = null;
  private SootMethod mMethod = null;
  private List<Block> mBlocks = null;
  private List<Unit> mUnits = null;
  private int mId = -1;
  private UnitGraph mUnitGraph = null;

  // The following are needed to create a tree of regions based on the containment (dependency)
  // relation between regions.
  private IRegion mParent = null;
  private List<IRegion> mChildren = new ArrayList<>();

  public Region(int id, SootMethod m, SootClass c, UnitGraph ug) {
    this(id, new ArrayList<Block>(), m, c, ug);

  }

  public Region(int id, List<Block> blocks, SootMethod m, SootClass c, UnitGraph ug) {

    this.mBlocks = blocks;
    this.mId = id;
    this.mMethod = m;
    this.mClass = c;
    this.mUnitGraph = ug;
    this.mUnits = null;

  }

  @Override
@SuppressWarnings("unchecked")
  public Object clone() {
    Region r = new Region(this.mId, this.mMethod, this.mClass, this.mUnitGraph);
    r.mBlocks = (List<Block>) ((ArrayList<Block>) this.mBlocks).clone();

    return r;

  }

  @Override
public SootMethod getSootMethod() {
    return this.mMethod;
  }

  @Override
public SootClass getSootClass() {
    return this.mClass;
  }

  @Override
public List<Block> getBlocks() {
    return this.mBlocks;
  }

  @Override
public UnitGraph getUnitGraph() {
    return this.mUnitGraph;
  }

  @Override
public List<Unit> getUnits() {
    if (this.mUnits == null) {
      this.mUnits = new LinkedList<>();
      for (Iterator<Block> itr = this.mBlocks.iterator(); itr.hasNext();) {
        Block b = itr.next();
        for (Unit u : b) {
          ((LinkedList<Unit>) this.mUnits).addLast(u);

        }
      }

    }

    return this.mUnits;
  }

  @Override
public List<Unit> getUnits(Unit from, Unit to) {

    return mUnits.subList(mUnits.indexOf(from), mUnits.indexOf(to));

  }

  @Override
public Unit getLast() {
    boolean condition = this.mUnits != null && this.mUnits.size() > 0;
	if (condition) {
        return ((LinkedList<Unit>) this.mUnits).getLast();
      }

    return null;
  }

  @Override
public Unit getFirst() {
    boolean condition = this.mUnits != null && this.mUnits.size() > 0;
	if (condition) {
        return ((LinkedList<Unit>) this.mUnits).getFirst();
      }

    return null;
  }

  public void add(Block b) {
    // Add to the front
    this.mBlocks.add(0, b);

  }

  public void add2Back(Block b) {
    // Add to the last
    this.mBlocks.add(this.mBlocks.size(), b);

  }

  public void remove(Block b) {
    this.mBlocks.remove(b);
    // make the units be recalculated.
    this.mUnits = null;
  }

  @Override
public int getID() {
    return this.mId;
  }

  @Override
public boolean occursBefore(Unit u1, Unit u2) {
    int i = this.mUnits.lastIndexOf(u1);
    int j = this.mUnits.lastIndexOf(u2);

    if (i == -1 || j == -1) {
      throw new RuntimeException("These units don't exist in the region!");
    }

    return i < j;
  }

  @Override
public void setParent(IRegion pr) {
    this.mParent = pr;
  }

  @Override
public IRegion getParent() {
    return this.mParent;
  }

  @Override
public void addChildRegion(IRegion chr) {
    if (!this.mChildren.contains(chr)) {
      this.mChildren.add(chr);
    }
  }

  @Override
public List<IRegion> getChildRegions() {
    return this.mChildren;
  }

  @Override
public String toString() {
    String str = "";
    str += new StringBuilder().append("Begin-----------Region:  ").append(this.mId).append("-------------\n").toString();

    List<Unit> regionUnits = this.getUnits();
    for (Unit u : regionUnits) {
      str += u + "\n";

    }
    str += new StringBuilder().append("End Region ").append(this.mId).append(" -----------------------------\n").toString();

    return str;

  }

}
